# 神山まるごと高専2期生版ポケットモンスターNikipoke草案

## 1. 目的
`engine-rust` ディレクトリにあるバトルロジックを使用し、ブラウザ上で実際に遊べる通信型のポケモンバトルアプリケーションを作成する。
AI（Minimax/MCTS）との対戦および、Socket.io を用いたリアルタイム対戦を可能にする。

## 2. 技術スタック
- **Frontend**: React, Tailwind CSS, Lucide React
- **Backend**: Node.js, Express, Socket.io
- **AI**: Minimax法 / MCTS (Monte Carlo Tree Search) (MLPも検討)
- **Engine**: 既存の `engine-rust` をコアロジックとして利用

## 3. 主要機能
### 3.1 バトルモード
- **Player vs AI**: AI (Minimax または MCTS) と対戦。
- **Player vs Player**: 特定のルームに入室して他のプレイヤーと対戦。
- **AI vs AI (観戦)**: 強化学習やアルゴリズムの比較用。

### 3.2 UI 画面
- **タイトル画面**: Nikipokeのロゴとスタートボタン。ログインボタン
- **ログイン画面**: ユーザー名とパスワードの入力。新規登録ボタン(google認証を予定)。
- **ホーム画面**: ユーザー名表示、バトル選択、ポケモン詳細（リスト）、ポケモンのデッキを作成するボタン
- **ポケモン詳細画面**: ポケモンの詳細を表示する。
- **デッキ作成画面**: ポケモンのリストから三匹選択してデッキを作成する。
- **ロビー画面**: プレイヤー名は自動で、モード選択、ルームID入力。
- **バトル画面**: 
    - 自分のモンスターと相手のモンスターのステータス（HP, レベル, 状態異常）。
    - 自分のポケモンの写真と名前を表示(写真は未実装)
    - フィールドや特殊状態もエフェクトとして見えるようにしたい
    - 技選択ボタン（4つの技）。
    - モンスター交代ボタン。
    - バトルログ（メッセージ表示）。
    - リザルト画面へ戻るボタン。
    (ここは`game_match.md`を参考にしてください)
- **リザルト画面**: 勝敗結果、リプレイ保存、タイトルへ戻る。

### 3.3 AI 実装案
- **Minimax**: 
    - `stepBattle` をシミュレートして数ターン先を読み、評価関数（HP、有利対面、状態異常、ステータスランク）で最善手を選択。
- **MCTS**: 
    - プレイアウトを繰り返し、勝利確率の高い手を選択。

## 4. 通信仕様 (Socket.io)
### Client -> Server
- `join_room`: ルームへの入室（ID、チーム情報）。
- `submit_action`: 技の選択または交代の送信。

### Server -> Client
- `battle_init`: 対戦開始時の初期状態（相手のチーム情報など）。
- `battle_update`: 毎ターンの結果（ログ、更新されたHP、アニメーションキュー）。
- `battle_end`: 対戦終了通知と最終結果。

### 4.1 バトルログ・統計（保存対象）
- 使用ポケモン（対戦ごとの構成）
- 使用技の履歴
- 勝敗結果（勝者/敗者、ターン数）
- ユーザー勝率、ポケモン勝率、技勝率
- デッキごとの勝率

### 4.2 集計の指針（先輩メモ）
- **対戦終了時に確定ログ保存**: battle_end 時に「対戦ログの正」を保存しておく。
- **集計は非同期でOK**: 勝率やランキングはバッチ/キューで後から更新でも十分。
- **リアルタイムは軽く**: 対戦中はログ追加のみ、重い集計は避ける。
- **集計ロジックは1箇所に**: 後から指標が増えても一括で直せる形にする。
- **集計の粒度を明記**: 「全期間」「直近N試合」「シーズン」などを最初に決める。
- **再計算できる前提で設計**: 失敗時に再集計できるよう、元ログを残しておく。

### 4.3 DB設計の粒度（先輩メモ）
- **ログと集計は分ける**: 対戦ログは正、勝率などは集計テーブルへ。
- **ログは冗長でもOK**: 後から再計算できるよう、必要情報は全部持つ。
- **スナップショットを残す**: 使用ポケモン/技/デッキは「当時の状態」で保存。
- **集計テーブルは更新前提**: 勝率は逐次更新 or バッチ更新を想定して設計。
- **履歴テーブルを用意**: シーズン単位や期間別の集計に使える。

## 5. ロードマップ

### Phase 0: 要件整理・設計
- 画面遷移図、UIワイヤーの作成
- 対戦状態のデータモデル定義（バトル状態、ログ、ターン情報）
- Socket.io イベント仕様の確定（payload も含む）
- engine-rust のI/O確認（入力と出力の型・粒度）

### Phase 1: UIモックと基本遷移
- タイトル/ログイン/ホーム/デッキ/ロビー/バトル/リザルトの画面骨組み
- スタイルの土台（Tailwind 設定、デザインルール）
- 画面遷移の確認（仮データでOK）

### Phase 2: シングルプレイ（ローカル対戦）
- engine-rust を使ったローカル対戦の実装
- 技選択/交代が UI から反映される
- バトルログ/HP 変化の描画

### Phase 3: Socket.io を使った PvP
- ルーム作成/参加/切断処理
- ターン同期、バトル状態の受け渡し
- 対戦開始/終了の通知とリザルト反映

### Phase 4: AI 対戦（ベース）
- Minimax or MCTS のどちらかを先に実装
- 評価関数の最低限実装（HP/有利対面/状態異常）
- ローカル対戦への組み込み

### Phase 5: AI強化・観戦
- 評価関数の改善、プレイアウトの高速化
- AI vs AI の観戦モード
- 対戦ログの可視化改善

### Phase 6: UX改善・リリース準備
- エフェクト/アニメーション追加
- リプレイ保存、共有の検討
- 認証/ユーザー保存（必要なら）

## 6. 実装の俯瞰的アイデア・助言（先輩からの微調整メモ）
- **stateを共通化**: バトル状態は frontend / backend / engine で同じ形に寄せる。型のズレが一番バグの温床。
- **責務の境界を明確に**: クライアントは入力と描画だけ、状態更新はサーバーで一元化。
- **「1ターン=1イベント」を守る**: 1アクション送る→1結果返す、を徹底すると同期ズレが減る。
- **ログを一次情報に**: 画面描画はログベースにしておくと演出追加が圧倒的に楽。
- **最初は勝てるAIより回るAI**: まずは簡易評価で動作優先、強化は後で十分。
- **通信は冪等に**: `battle_update` は同じ状態を再送されても安全に描画できる形にする。
- **デバッグ視点を先に仕込む**: バトル状態をJSON保存/再生できるだけで検証が速くなる。
- **UIは先に「仮データ」で完成させる**: データ待ちでUIが止まるのが一番もったいない。
- **「動くデモ」を最速で**: MVP到達が早いほど、チーム内の合意形成がスムーズになる。
